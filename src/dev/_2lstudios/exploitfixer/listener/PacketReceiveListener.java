package dev._2lstudios.exploitfixer.listener;

import dev._2lstudios.exploitfixer.exploit.BukkitExploitPlayer;
import dev._2lstudios.exploitfixer.managers.ExploitPlayerManager;
import dev._2lstudios.exploitfixer.managers.ModuleManager;
import dev._2lstudios.exploitfixer.modules.BukkitNotificationsModule;
import dev._2lstudios.exploitfixer.modules.CommandsModule;
import dev._2lstudios.exploitfixer.modules.ItemsFixModule;
import dev._2lstudios.exploitfixer.modules.PacketsModule;
import dev._2lstudios.exploitfixer.utils.ExploitUtil;
import dev._2lstudios.hamsterapi.enums.PacketType;
import dev._2lstudios.hamsterapi.events.PacketReceiveEvent;
import dev._2lstudios.hamsterapi.hamsterplayer.HamsterPlayer;
import dev._2lstudios.hamsterapi.wrappers.PacketWrapper;
import org.bukkit.Bukkit;
import org.bukkit.GameMode;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.Cancellable;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryView;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;

import java.util.Map;
import java.util.Map.Entry;

public class PacketReceiveListener implements Listener {
    private final ExploitUtil exploitUtil;
    private final ExploitPlayerManager exploitPlayerManager;
    private final ItemsFixModule itemsFixModule;
    private final BukkitNotificationsModule notificationsModule;
    private final PacketsModule packetsModule;
    private final CommandsModule commandsModule;
    private final String version;
    private final boolean checkLectern;

    PacketReceiveListener(final ExploitUtil exploitUtil, final ModuleManager moduleManager) {
        this.exploitUtil = exploitUtil;
        this.exploitPlayerManager = moduleManager.getExploitPlayerManager();
        this.itemsFixModule = moduleManager.getItemsFixModule();
        this.notificationsModule = moduleManager.getNotificationsModule();
        this.packetsModule = moduleManager.getPacketsModule();
        this.commandsModule = moduleManager.getCommandsModule();
        this.version = Bukkit.getServer().getClass().getPackage().getName().split("\\.")[3];
        this.checkLectern = version.equals("v1_18_R1")
                || version.startsWith("v1_17") || version.startsWith("v1_16")
                || version.startsWith("v1_15") || version.startsWith("v1_14")
                || version.startsWith("v1_13") || version.startsWith("v1_12")
                || version.startsWith("v1_11") || version.startsWith("v1_10");
    }

    public void onPacketReceive(final Cancellable event, final HamsterPlayer hamsterPlayer, final Player player,
            final PacketWrapper packetWrapper) {
        final PacketType packetType = packetWrapper.getType();
        final String packetName = packetWrapper.getName();
        final String playerName = player.getName();
        final Map<String, String> strings = packetWrapper.getStrings();
        final BukkitExploitPlayer exploitPlayer = exploitPlayerManager.get(player);
        final double dataVls = packetsModule.getDataVls();
        final Map<String, Integer> integers = packetWrapper.getIntegers();
        final InventoryView inventoryView = player.getOpenInventory();
        final double windowClick = packetsModule.getWindowClick();
        final double setCreativeSlot = packetsModule.getSetCreativeSlot();

        exploitPlayer.addVls(event, hamsterPlayer, packetsModule, packetsModule.getMultiplier(packetName));

        if (packetsModule.isBlacklisted(packetName)) {
            final String reason = "[" + packetName + "] " + playerName + " sent a Blacklisted packet!";

            exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, 0);
            return;
        }

        if (commandsModule.isEnabled() && packetType == PacketType.PacketPlayInTabComplete) {
            if (!strings.isEmpty()) {
                final String rawMessage = strings.values().iterator().next();

                if (commandsModule.isCommand(rawMessage)) {
                    exploitPlayer.punish(commandsModule, hamsterPlayer, packetWrapper, commandsModule.getPunishments(),
                            1);
                    event.setCancelled(true);
                    return;
                }
            }
        }

        if (packetType == PacketType.PacketPlayInCustomPayload) {
            if (!strings.isEmpty()) {
                final String tag = strings.values().iterator().next();
                final double tagVls = packetsModule.getTagVls();
                final double bookVls = packetsModule.getBookVls();

                if (tagVls > 0 && (tag == null || tag.isEmpty())) {
                    final String reason = "[" + packetName + "|Tag] " + playerName
                            + " sent a CustomPayload packet without TAG! Added vls: " + tagVls;

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, tagVls);
                    return;
                } else if (bookVls > 0
                        && (tag.equals("MC|BEdit") || tag.equals("MC|BSign") || tag.equals("MC|BOpen"))) {
                    final PlayerInventory playerInventory = player.getInventory();
                    final ItemStack itemInHand = playerInventory.getItem(playerInventory.getHeldItemSlot());

                    if (itemInHand != null && !itemInHand.getType().toString().contains("BOOK")) {
                        final String reason = "[" + packetName + "|Book] " + playerName + " tried to send a " + tag
                                + " CustomPayload packet without a book in hand!";

                        exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, bookVls);
                        return;
                    }
                } else if (tag.equals("MC|AdvCdm") && !player.isOp()) {
                    final String reason = "[" + packetName + "|Command Block] " + playerName + " tried to send a " + tag
                            + " CustomPayload packet without being op!";

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, bookVls);
                    return;
                }

                exploitPlayer.addVls(event, hamsterPlayer, packetsModule, packetsModule.getMultiplier(tag));
            } else {
                notificationsModule.debug("[" + packetName + "] " + playerName + " sent a empty CustomPayload packet!");

                event.setCancelled(true);
            }
        }

        if (windowClick > 0 && packetType == PacketType.PacketPlayInWindowClick) {
            final Inventory topInventory = inventoryView.getTopInventory();

            if (topInventory.getType().name().equals("LECTERN")) {
                if (this.checkLectern) {
                    if (version.equals("v1_18_R1")) {
                        if (integers.containsKey("a") && integers.get("a") == 1) {
                            final String reason = "[" + packetName + "|WindowClick] " + playerName
                                    + " tried to quick move on a lectern! Added vls: "
                                    + windowClick;

                            exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, windowClick);
                            return;
                        }
                    } else {
                        if (integers.containsKey("b") && integers.get("b") == 1) {
                            final String reason = "[" + packetName + "|WindowClick] " + playerName
                                    + " tried to quick move on a lectern! Added vls: "
                                    + windowClick;

                            exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, windowClick);
                            return;
                        }
                    }
                }
            }

            final Inventory bottomInventory = inventoryView.getBottomInventory();
            final boolean containsSlot = integers.containsKey("slot");

            if (containsSlot || integers.containsKey("d")) {
                final int slot = containsSlot ? integers.get("slot") : integers.get("d");
                final int maxSlots;

                if (bottomInventory.getType() == InventoryType.PLAYER
                        && topInventory.getType() == InventoryType.CRAFTING) {
                    maxSlots = inventoryView.countSlots() + 4;
                } else {
                    maxSlots = inventoryView.countSlots();
                }

                if (slot < 0 && slot != -999 && slot != -1) {
                    final String reason = "[" + packetName + "|WindowClick] " + playerName
                            + " sent a slot less than 0 and not [-999 or -1]! Slot: " + slot + " Added vls: "
                            + windowClick;
                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, windowClick);
                    return;
                } else if (slot >= maxSlots) {
                    final String reason = "[" + packetName + "|WindowClick] " + playerName
                            + " exceeded max available slots! (" + slot + "/" + maxSlots + ") Added vls: "
                            + windowClick;
                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, windowClick);
                    return;
                }
            }
        }

        if (setCreativeSlot > 0 && packetType == PacketType.PacketPlayInSetCreativeSlot
                && player.getGameMode() != GameMode.CREATIVE) {
            final String reason = "[" + packetName + "|SetCreativeSlot] " + playerName
                    + " sent SET_CREATIVE_SLOT without CREATIVE! Added vls: " + setCreativeSlot;

            exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, setCreativeSlot);
            return;
        }

        if (dataVls > 0) {
            if (packetType == PacketType.PacketPlayInUpdateSign
                    && !exploitUtil.checkSign(strings.values().toArray(new String[0]))) {
                final String reason = "[" + packetName + "|Data] " + playerName
                        + " has sent a too big sign packet! Added vls: " + dataVls;

                exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
                return;
            }
        }

        final boolean creativeMode = packetType == PacketType.PacketPlayInSetCreativeSlot && itemsFixModule.isEnabled();

        for (final Entry<String, ItemStack> itemsEntry : packetWrapper.getItems().entrySet()) {
            final ItemStack item = itemsEntry.getValue();

            if (item != null) {
                if (dataVls > 0 && !exploitUtil.checkItem(item)) {
                    final String reason = "[" + packetName + "|Data] " + playerName
                            + " sent an invalid item! Added vls: " + dataVls;

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
                    return;
                } else if (creativeMode) {
                    final String blacklisted = exploitUtil.clearIfBlacklisted(item);

                    if (blacklisted != null) {
                        packetWrapper.write(itemsEntry.getKey(), new ItemStack(Material.AIR));
                        notificationsModule.debug(
                                playerName + " had a creative item blacklisted by ExploitFixer! (" + blacklisted + ")");
                    } else {
                        packetWrapper.write(itemsEntry.getKey(), itemsFixModule.fixItem(item));
                        notificationsModule.debug(playerName + " had a creative item fixed by ExploitFixer!");
                    }
                }
            }
        }

        if (dataVls > 0) {
            for (final float val : packetWrapper.getFloats().values()) {
                if (val > Float.MAX_VALUE || val < Float.MIN_VALUE) {
                    final String reason = "[" + packetName + "|Data] " + playerName
                            + " sent an invalid float! Added vls: " + dataVls;

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
                    return;
                }
            }

            for (final double val : packetWrapper.getDouble().values()) {
                if (val > Double.MAX_VALUE || val < Double.MIN_VALUE) {
                    final String reason = "[" + packetName + "|Data] " + playerName
                            + " sent an invalid double! Added vls: " + dataVls;

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
                    return;
                }
            }

            for (final int val : integers.values()) {
                if (val > Integer.MAX_VALUE || val < Integer.MIN_VALUE) {
                    final String reason = "[" + packetName + "|Data] " + playerName
                            + " sent an invalid integer! Added vls: " + dataVls;

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
                    return;
                }
            }
        }

        notificationsModule.addPacketDebug(String.valueOf(packetType));
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.LOWEST)
    public void onPacketReceive(final PacketReceiveEvent event) {
        if (!packetsModule.isEnabled()) {
            return;
        }

        final HamsterPlayer hamsterPlayer = event.getHamsterPlayer();

        onPacketReceive(event, hamsterPlayer, hamsterPlayer.getPlayer(), event.getPacket());
    }
}
